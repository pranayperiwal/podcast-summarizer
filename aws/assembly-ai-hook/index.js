const { PutObjectCommand, S3Client } = require("@aws-sdk/client-s3");
const { Configuration, OpenAIApi } = require("openai");
const fetch = require("node-fetch");
const { PrismaClient } = require("@prisma/client");

const sgMail = require("@sendgrid/mail");

sgMail.setApiKey(process.env.SENDGRID_API_KEY);

const prisma = new PrismaClient();

const configuration = new Configuration({
  apiKey: process.env.OPENAI_API_KEY,
});

const openai = new OpenAIApi(configuration);

const client = new S3Client({
  region: "ap-southeast-1",
  credentials: {
    accessKeyId: process.env.AWS_S3_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_S3_SECRET_KEY_ID,
  },
});

const createSendEmailMsg = (
  toAddress,
  fromAddress,
  podcastName,
  showName,
  summaryURL
) => {
  return {
    to: toAddress,
    from: {
      email: fromAddress,
      name: "PodCrunch Summary",
    },
    subject: "Podcast summary was successful!",
    templateId: "d-f138b2b1578e45d996422dd15e6754e5",
    dynamic_template_data: {
      podcastName,
      showName,
      summaryURL,
    },
  };
};

exports.handler = async (event) => {
  try {
    //for each message in queue received
    for (const record of event.Records) {
      //gets the transcript_id and hashValue from SQS
      const { body } = record;
      console.log("Message from queue: ", body);
      const { transcript_id, hashValue } = JSON.parse(body);

      //update status to processing
      await updateRequestDbStatus(hashValue, "Processing");

      // Get the transcript
      const transcriptFile = await getTranscriptFile(transcript_id);

      console.log(
        "Summary generated by assembly AI: \n" + transcriptFile.summary
      );
      console.log("Got Transcript File. Generating Summary...");

      //generate summary
      const summary = await generateSummary(transcriptFile);
      console.log("Generated Summary.");

      const summaryJson = {
        summary: summary,
      };

      // Upload summary to S3
      await saveTranscriptToS3(hashValue, summaryJson);

      // Update the status of the request to Completed
      const currentRequest = await updateRequestDbStatus(
        hashValue,
        "Completed"
      );
      console.log(
        "Updated Request DB Status to Completed for podcast: " + hashValue
      );

      //send confirmation email
      // 1. check who all have requested the summary
      const emails = await prisma.user.findMany({
        where: {
          request: {
            some: {
              podcast_hash: hashValue,
            },
          },
        },
        distinct: ["email"],
        select: {
          email: true,
        },
      });

      const emailList = emails.map((user) => user.email);
      // 2. send emails to everyone about confirmation

      const emailPromises = emailList.map((email) =>
        sendConfirmationEmail(
          email,
          currentRequest.podcastUpdate.episode_name,
          currentRequest.podcastUpdate.show_name,
          "podcrunch.co/library/" + hashValue
        )
      );

      // Wait for all email promises to complete
      await Promise.all(emailPromises);
    }

    return {
      statusCode: 200,
      body: JSON.stringify({
        message: "success",
      }),
    };
  } catch (err) {
    await updateRequestDbStatus(hashValue, "Error");
    console.error(err);
    return {
      statusCode: 404,
      body: JSON.stringify({
        message: err.message,
      }),
    };
  }
};

async function getTranscriptFile(transcriptId) {
  try {
    const pollingEndpoint = `https://api.assemblyai.com/v2/transcript/${transcriptId}`;

    const headers = {
      Authorization: process.env.ASSEMBLY_API_KEY,
    };

    for (let i = 0; i <= 10; i++) {
      console.log("Polling Attempt...");
      try {
        const pollingResponse = await fetch(pollingEndpoint, {
          method: "GET",
          headers: headers,
        });

        console.log(pollingResponse);

        if (pollingResponse.ok) {
          const transcriptionResult = await pollingResponse.json();
          console.log(transcriptionResult);
          if (transcriptionResult.status === "completed") {
            return transcriptionResult;
          } else if (transcriptionResult.status === "error") {
            throw new Error(
              `Transcription failed: ${transcriptionResult.error}`
            );
          } else {
            await new Promise((resolve) => setTimeout(resolve, 3000));
          }
        } else {
          // Retry the polling after a delay if the response is not ok
          await new Promise((resolve) => setTimeout(resolve, 3000));
        }
      } catch (error) {
        console.error("Error:", error);
        // Handle the error here
        await new Promise((resolve) => setTimeout(resolve, 3000));
      }
    }

    throw new Error("Polling attempts exceeded.");
  } catch (error) {
    throw new Error(`Error: ${error.message}`);
  }
}

async function saveTranscriptToS3(fileName, transcriptData) {
  const dataBuf = Buffer.from(JSON.stringify(transcriptData));

  const data = new PutObjectCommand({
    Bucket: process.env.TRANSCRIPT_BUCKET,
    Key: `${fileName}.json`,
    Body: dataBuf,
  });

  const response = await client.send(data);
  console.log("Saving summary s3 response: ", response);
}

async function generateSummary(transcriptFile) {
  let utteranceIndex = 0;

  let summary = [];
  let chapterNumber = 1;

  for (const chapter of transcriptFile.chapters) {
    console.log(`Generating for Chapter: ${chapterNumber}`);
    let start = chapter["start"];
    let end = chapter["end"];
    chapterNumber++;

    console.log(start + " " + end);

    let chapterContent = "";
    chapterContent += "Chapter: " + chapter["gist"] + "\n";

    while (
      utteranceIndex < transcriptFile["utterances"].length &&
      transcriptFile["utterances"][utteranceIndex]["end"] <= end
    ) {
      const utterance = transcriptFile["utterances"][utteranceIndex];
      chapterContent +=
        utterance["speaker"] +
        `(${utterance["start"]} - ${utterance["end"]}): \n`;
      chapterContent += utterance["text"] + "\n";
      utteranceIndex++;
    }

    // console.log(chapterContent);

    const chatCompletion = await openai.createChatCompletion({
      model: "gpt-3.5-turbo-16k",
      messages: [
        {
          role: "system",
          content:
            "You are a podcast summariser. You will be given a chapter of the podcast. No need to mention the chapter name. Describe in short the main details and information discussed.",
        },
        { role: "user", content: chapterContent },
      ],
    });
    summary.push({
      title: chapter["gist"],
      summary: chatCompletion.data.choices[0].message["content"],
      start: start,
      end: end,
    });
  }

  return summary;
}

function generatePrompt() {
  return "You are given the task to summarise a transcribed script of a podcast. Break down the text into relevant chapters and summarise each chapter capturing main details and key points. Make sure the summary includes relevant details and examples that support the main ideas while avoiding any unnecessary information or repetition. In case there is repetition across chapters then add it to the existing chapter";
}

async function updateRequestDbStatus(podcastHash, newStatus) {
  if (newStatus === "Completed") {
    const requestUpdate = await prisma.request.updateMany({
      where: {
        podcast_hash: podcastHash,
      },
      data: {
        status: newStatus,
      },
    });

    const podcastUpdate = await prisma.podcast.update({
      where: {
        hash: podcastHash,
      },
      data: {
        summary_complete: true,
      },
    });

    return { requestUpdate, podcastUpdate };
  }
  return await prisma.request.updateMany({
    where: {
      podcast_hash: podcastHash,
    },
    data: {
      status: newStatus,
    },
  });
}

const sendConfirmationEmail = async (
  receiverEmail,
  podcastName,
  showName,
  summaryURL
) => {
  const msg = createSendEmailMsg(
    receiverEmail,
    "summary@podcrunch.co",
    podcastName,
    showName,
    summaryURL
  );

  await sgMail
    .send(msg)
    .then(() => {
      console.log("Email sent");
    })
    .catch((error) => {
      console.error(error);
    });

  console.log(
    "Summary complete email sent: ",
    receiverEmail,
    podcastName,
    showName,
    summaryURL
  );
};
